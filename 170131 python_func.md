## 스코프(영역)

내장 (bulit-in) 
전역 영역 (global scope) : 메인 프로그램의 영역. 
지역 (local scope) : 전역 안에서 독립적으로 함수가 갖고 있는 영역.

### 스코핑 룰
외부 영역에서 내부 영역의 데이터를 사용 할 수 없다. 내부 영역에서는 외부영역의 데이터를 참조 가능하다. (반대의 경우에는 함수의 인자로 데이터를 전달)

글로벌 변수 : 글로벌 스코프에서 선언된 변수다. 로컬 영역에서 사용할 때 `global` 키워드를 변수 앞에 붙여서 직접 명시해주어야 한다. 로컬 내부에서 만약 참조할 변수가 없으면 글로벌 변수 중에서 찾아서 사용하기도 하지만, 별로 좋은 방법은 아니기 때문이다. 
global()로 확인해 볼 수 있다.


로컬 변수 : 함수의 로컬영역에서 선언된 변수다. 글로벌 영역에서는 참조할 수 없고 로컬영역 안에서만 참조할 수 있다. 글로벌 영역에서 사용하기 위해서는 함수가 반환해줘야 한다. 
locals()로 확인해 볼 수 있다.



### 내장함수와 내역 영역

내장 함수들은  `__builtin__`변수(전역 스코프에 위치)에 할당되어 있다. 
내장 영역 확인시 dir 함수 사용.

 
### 로컬 스코프에서 글로벌 스코프의 변수 사용 


change_global_champion()
안의 champion='Ahri' 는 지역변수이다. 그래서 글로벌 변수 값을 바꿔주는 코드가 아님. 로컬 스코프에서 바뀐 값이 글로벌에 영향을 줄 수 없다.

그래서 show_gloabl_champion()해도 여전히 champion : Lux를 보여주고 있는 것임.

이 둘은 같은 이름ㅁ의 변수이지만 id 값도 다르다. 왜냐하면 참조하는 객체가 각자 lux와 ahri로 다르기 때문.

로컬 스코프에서 글로벌 변수의 값을 바꿔주려면 global키워드로 변수가 글로벌 스코프에 존재한다는 것을 알려주어야 한다.

```python
champion = 'Lux'

def show_global_champion():
    print('show_global_champion : {}'.format(champion))

def change_global_champion():
    print('before change_global_champion : {}'.format(champion))
    champion = 'Ahri'
    print('after change_global_champion : {}'.format(champion))

show_global_champion()
change_global_champion()


UnboundLocalError: local variable 'champion' referenced before assignment
```

->로컬 변수가 생성돼있는데, print구문보다 아래에 선언돼 있어서 에러남.

>첫 번째 코드에서는 champion변수가 함수의 로컬 스코프에 존재하지 않기 때문에 글로블 스코프에서 해당 변수를 찾아 출력하였으나, 이번 코드에서는 내부에 또다른 champion변수가 로컬변수로 존재하기 때문에 글로벌 스코프에서 찾지 않고, 할당(선언)하기 전인 로컬 변수를 사용한 것으로 판단하여 프로그램에서 오류를 발생시킨다.


* locals() 로 현재 스코프에서 사용중인 변수들을 확인해 볼 수 있다.

* 파이썬은 이름이 같은 변수는 글로벌만 쓰거나 로컬만 쓰거나 둘 중 하나를 선택해야 한다. 같은 이름의 변수가 함수 내에서 글로벌<->로컬을 왔다갔다 할 수 없고 하나로만 써야한다. 글로벌 변수로 쓰려면 글로벌로만 쓸 수 있다.
한 스코프에서 동일한 이름의 두 스코프의 변수를 사용할 수 없다.

### 내부함수에서의 로컬 스코프 (nonlocal)
```python
champion = 'Lux'

def local1():
    champion = 'Ahri'
    print('local1 locals() : {}'.format(locals()))

    def local2():
        champion = 'Ezreal'
        print('local2 locals() : {}'.format(locals()))
    local2()

print('global locals() : {}'.format(locals()))
local1()
```
로컬 스코프 내부에 또다른 로컬 스코프를 만들었다. 자기보다 위의 로컬스코프의 변수를 사용하려면 nonlocal키워드를 사용한다. 

scope/nonlocal.py 실습

### global키워드와 인자(argument)전달의 차이

diff_global_arguments.py

메모리에 생긴 객체 100 과 130

변수 참조가 바뀜, id로 확인해봐야할 듯.

리스트의 경우 value와 global이 모두 같은 객체를 참조한다. 그래서 바뀐 값이 확인된다.

### 람다함수
lambda.py

### 클로져
각 파일마다(모듈마다) 로컬과 글로벌이 생긴다. 

각 모듈마다 환경이 새로 생긴다.
모듈a의 클로져 와 모듈b의 클로져가 따로 생김.

서로 쓸때는 함수의 인자로 전달.

import from as ~~~ 로 해줄수도 있다.

함수가 동작할때는 자기가 정의된 클로져 안에 있는 변수를 쓴다. 

다른 모듈에서 정의된 함수를 사용하면서 인자로 자기 모듈의 값을 넣어줄 수도 있다. 

inner_closure.py 
어떤 함수의 지역변수를 유지하면서 그것으로 계속 동작하게 하고 싶을때 내부 함수를 만들어서 그 지역변수를 사용해서 동작하게 만든다. 
(내부함수가 생기면서 그 클로져도 새로 생기게된다. 메모리에서도 다른 객체로 생긴다. 이때 내부함수가 nonlocal로 그 지역변수를 사용하므로 이 지역변수도 클로져에 포함돼 새로 생기게 된다. 그래서 원래의 지역변수는 그대로 유지하면서도 내부함수를 통해 계속 조작할 수 있다. ) 

### 터코레이터

함수를 직접 변경하지 않고도 기능을 추가할 수 있다. 

데코레이터 선언 혹은 인자로 함수에 인자로 전달.

특정함수가 실행될때 로그(함수가 실행되는 기록)를 남기거나 할때 데코레이터를 많이 쓴다. 


함수가 데코레이터로 동작하게 함수위에 선언해주면된다.선언해뒀을 경우 가까운쪽 붜터 실행된다. 물론 데코레이터를 직접 실행시킬수도 있다. 

### 터네레이터
시퀀스가 어떻게 생설될지에 대한 정보?를 갖고있다. 시퀀스를 생성할 수 있는 구문을 갖고 반복물을 돌아도 어느정도 쓸만큼만 갖고잇음. 즉 적은 메모리로 반복하면서 순 회 할 수 있다. 제네레이터는 한번만 순회할 수 이 메모리를 적게 차지 한다. 

순회가 끝나는 순간 사라진다. 
일회성이다. 

함수 매개변수 중
*args 는 리스트형태
**kwargs 는 딕셔너리 형태로 온다


a,b = b, a
이렇게만 함녀 값이 바뀐다