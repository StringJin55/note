* 프로그래머
* 프로그래밍
* 프로그램
컴퓨터에 의해 실행될 수 있는 일련의 기능 모음
* 컴퓨터
전자계산기

## 컴퓨터의 역사

* 왜 0과1인가?
최초의 컴퓨터 - 수학 연산을 위해 만든 전자계산기 
이진법이 십진법보다 계산에 용이해서(효율적) 이진법을 중심으로 만들어짐. 

초기에는 전선을 꽃앗다가 빼면서

* 진공관 - 신호를 증폭
1세대 컴퓨터
문제점 - 열, 잘 깨짐, 곤충이 모여든다(빛과 열때문에)-합선  버그잡는다는게 여기서 유래? 

* 다이오드 - 전류를 보내고 안보내고 (1과 0)

* 트랜지스터 - 증폭, 신호를 조작
2세대 컴퓨터
컴퓨터의 크기가 더 작아짐 (방하나 크기)

* 집적회로 (IC칩) - 트랜지스터 4개를 하나로 붙인게 최초의 직접회로 
3세대 컴퓨터 

## 컴퓨터의 구성

#### 하드웨어
* 입력장치
* 출력장치
* 기억장치
	* 주기억장치 - 램 (빠름 전원이꺼지면 데이터가 지워짐) - 왜 주기억장치인가? (빠르고, 핵심부품?)
	* 보조기억장치 - 하드디스크 ( 매우 느림 전원이 꺼져도 데이터가 지워지지 않음)
* 제어/연산장치
	* 중앙처리장치 CPU

#### 소프트웨어
* 시스템 소프트웨어
	* 운영체제 
	* 커널 (운영체제 안에 속해있음)
* 응용 소프트웨어 == 애플리케이션
	시스템 소프트웨어에 종속적. 

## 컴퓨터 구조

#### 하버드 구조 - 폰 노이만 구조의 변형 
프로그램 메모리와 데이터 메모리가 물리적으로 분리/ 속도가 빠름/ 구성에 비용이 많이들며 복잡

#### 폰 노이만 구조 - 먼저 나왔다.
프로그램 메모리와 데이터 메모리가 구분되지 않고 하나의 버스(데이터가 지나다니는 통로)를 가지고 있음 / 메모리 속박 문제 및 버스 병목 문제를 가짐

#### 차이점
폰 노이만 구조는 길이 하나다. 
통로는 수로와 비슷. 한번에 한방향으로만 갈 수 있다. 예를 들어 폰노이만에서 메모리에서 데이터를 연산장치로 보내는 동안은 제어장치가 메모리에 접근해서 명령어를 가져올 수 없다. 하버드 구조는 통로가 분리되어 있기 때문에 독립적으로 메모리 접근할 수 있어 효율적이고 빠르다. 

하버드 구조는 대신 하드웨어적으로 부피가 더 크고 비쌈. 

#### 현재의 컴퓨터
두 구조를 절충하여 쓰고있다. 큰 틀은 폰노이만 구조 - 안에 하버드 구조를 섞어서 쓰구 있다. 기술의 발달로 하버드 구조 비용문제도 해결. 

#### 하버드 + 폰노이만
* CPU의 캐시 메모리 형상
CPU 내부 - 하버드
CPU 외부 - 폰노이만

L1,L2캐시 - 제어장치(CU)옆에 미리 갖다놓은 메모리. CU가 처리중인동안 저기에 메모리가 미리 데이터와 명령어를 갖다 놓으면 CU가 후에 버스가 막혀있는동안 기다리지 않아도 L1,L2에서 갖다가 처리 할 수 있다. (폰노이만의 문제 해결 가능) - cpu안의 하버드 구조

> 통상적으로 L1은 명령어, L2는 데이터 처리 해서 L1캐시가 더 작다. 제조사 설계에 따라 다름. 
> 메모리 속박 문제 - cpu연산 속도와 메모리 접근 속도의 차이로 생기는 문제. cpu연산하는 속도는 빨라졌는데 데이터를 불러오는데 걸리는 시간(전송속도) 가 더 오래 걸려서 생김. 

## 컴퓨터의 동작

cpu연산을 위해선 주기억 장치에 올라와야 한다

### 데이터의 표현방식

사람이 알아보기 쉽게 여러가지 방식으로 데이터를 표현한다.

#### 정수
컴퓨터는 2진수로 정수를 표현한다. 

프로그래밍을할때는 2, 8, 16진법을 많이 쓴다. 
16진수 : 0~F 16개 

* 굳이 16진수를 쓰는 이유? 
	(컴퓨터가 사용하는) 2진수와 변환하기 쉽다. 8비트를 나타내기도 쉽다. 
	네자리 2진수는 총 16가지의 경우의 수가 있는데 16진수로는 한자리로 딱 나타낼 수 있다. 
헥사코드 = 16진수 0xAEAE  저 x가 핵사를 나타낸다. 
옥타 = 8진수  0o1234 o는 옥타

비트 - 0과 1을 쓸수있는 한자리

#### 실수
부호비트+지수+가수 : 표현규칙 약속을 정했다.(IEEE754)

#### 문자
ASCII - 255개 문자를 표현가능. 완성형. 완성된 글자가 매핑. (한 문자에 8비트) - 처음 만들어질때 영어만 표현해서 충분했다. 
Unicode - 
UTF-8 - 유니코드 조합형 방식. 한요소를 16비트로 표현.
EUC-KR
CP 949

인코딩 : 데이터를 코드화. 컴퓨터가 알아볼 수 있게 부호로 바꿔준다.
 
조합형은 처음에 생각할 경우의 수가 적다. 자유롭게 만들어질 수 있으므로. 완성형은 모든 경우의수를 미리 만들어둬야 한다. 
우리나라 정부는 완성형 방식을 쓴다. 그래서 주민등록증에 자기 이름을 못 쓰는 사람도 있다. (euc-kr 이나 cp949) 왜냐하면 비용때문에 전산망 교체를 못하고 있다고 함. 

요즘에는 완성형보다 조합형을 쓴다. 
> 유니코드는 완성형으로 시작했지만 현재 UTF-8은 조합형. 

* 웹사이트 인코딩방식 확인해보기
	개발자도구로 html 헤드 정보보기

브라우저 기본 인코딩 방식 지정할 수 있다.

문자와 숫자등 데이터가 전부 0과 1로 이루어져 있지만 자료형을 명시해줘서 컴퓨터가 문자와 숫자를 구분할 수 있게 해준다. 

허용오차범위
(정수->실수 등)다른 수체계로 변환시키는 경우 - 소수점 절사 등 오차가 생길 수 밖에 없는 한계치가 있다. 
	* 우주선 폭발 같은 경우 - 이런 오차로 인한 것. 무한대 숫자를 사용해서 계산할 수 없기 때문에

64비트 프로세서는 64개의 다리(버스)가 있다. 

cpu에게 데이터가 메모리안의 어느위치에 있는지 위치를 알려준다.(주소) 버스(통로) 를 통해서 주소값을 전달한다. 이 통로의 크기가 프로세서의 비트수. 즉 32비트 cpu면 2의 32승인 4gb만큼의 통로의 크기. 주소도 2의 32승 만큼 있을 수 있고 매칭되는 통로도 그만큼. 그래서 4Gb만큼의 메모리 크기가 될 수 있다. 그래서 프로세서에서 4gb만큼 메모리를 쓸 수 있다.
64비트 프로세서는 192gb까지 가능. (버스 차선이 두개가 됨) 

### 32비트 / 64비트
한 단위를 나타내는 비트수가 커지면 나타낼 수 있는 데이터 영역도 커진다!

8bit == 1byte
64 bit == 8 byte

2^64bit == 192gb 

x86 : 32비트의 대명사. (286,386,486 - 인텔에서 32비트 프로세서 컴터에 붙인 이름)

메모리 관리는 운영체제가 해준다. 64비트 시스템에 32비트 운영체제 설치하면 메모리 다 못 씀. 데이터 타입 주소체계가 서로 다르기 때문. 


#### IPv4/IPv6 (IPversion4/)

* IPv4 : 32bit (255.255.255.255 : 8bit * 4 , `.`은 가상의 점이다. 표현을위한. 실제로는 나눠져있지않음)
* IPv6 : 128bit (이제 32bit로 전세계 컴퓨터 나타내기가 어렵기 때문에 등장. 2011년도에 ip주소가 고갈됨.통신 장비들에 호환이 안돼서 교체비용이 커서 아직 완벽하게 IPv6를 사용하고 있지 않다.) 


## 컴퓨터의 연산

#### 덧셈

컴퓨터는 덧셈밖에 할 줄 모른다. 컴퓨터안에는 가산기가 있다. 가산기란 덧셈을 할 수 있는 기계.

반가산기-연산을 하는 회로 2비트로 데이터를 받음. carry-자리수를 받음. 반가산기가 병렬로 32개,64개 연결된 것이 전가산기. 

#### 논리연산
* AND
	둘 중 둘다 1일때만 1 , 나머지 경우는 0 (1인 비트끼리의 연산에서만 1)
* OR
	둘 중 하나만 1이어도 1. 
* NOT
	0은 1로 1은 0으로 바꿔줌. 

#### 다른 연산들
곱셈, 뺄셈, 나눗셈등도 덧셈으로 전환해서 연산한다. 

#### 음수 표현
맨 앞자리 부호비트. 1이면 음수, 0이면 양수.
32비트 정수형 - 표현 범위는 -2^31 부터 (2^31 -1 ) 까지 표현가능. (0 포함돼서 ) 31제곱인 이유는 맨 앞자리는 부호비트이기 때문. 

* 2의 보수
	0011(2) = 3
	not 연산하면
	1100(2) 1의 보수
	+1 (그냥 약속이다)
	1101(2) 2의 보수 -3
	
	* 컴퓨터의 실제 뺄셈
	5-3의 연산에서 : 
	0101 - 0011 = 
	0101 + 1101 =
	0010(2) = 2 (10)
	overflow underflow(컴퓨터가 연산할 수 있는 자리수를 초과한 숫자) 가 발생.

#### 비트논리연산 - 한 비트씩 나눠 가지고 비트단위로 연산한다. 	

다중선택시 or연산으로 조합해서 보내기. -> and연산으로 해석하면 된다. 중복선택도 알 수 잇음.

* 데이터마스킹
	111111111111 이런거랑 AND 로 비교해보면 양수인지 정수인지 알아낼 수 있다. 
	혹은 특정 자리수의 수만 뽑아낼 수도 있다. 

#### 부울논리연산 - 참거짓을 다룬다
컴퓨터는 0이 아닌 모든것을 true로 인식함.

부호가 두개 && 이면 한 비트단위가 아니라 묶음 전체를 가지고 연산해서 참거짓을 나눈다. 
a && b 
	 
#### 비트논리연산 vs 부울논리연산
& vs &&
| vs || 

비트논리연산 - 각 비트별 0과 1 계산  0110 & 1101 = 0100
부울논리연산 - 참 거짓 판별 0110 && 1101 = true




 
## 과제  

컴퓨터가 2진수를 쓰는 이유. 최초에는 기계적으로 0과1로 셈하는게 쉬웠기 때문. 지금은 왜??

* 핸드아웃 연습문제 

* RAM은 어떤 단어들의 약자이며, 왜 RAM이라고 부르게 되었을까?
* 하버드 구조와 폰 노이만 구조의 한계는 각각 무엇이며 지금은 어떻게 구성된 모습으로 사용되고 있을까?
* 한글을 표현할 수 있는 문자 인코딩 방식에는 무엇이 있을까? 각각의 장단점. 
