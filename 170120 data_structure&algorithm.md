## 기본

### 알고리즘

문제해결을 위한 절차/방법
어떠한 문제를 해결하기 위한 여러 동작들의 모음

생활에서의 문제상황 - 우리는 알고리즘을 갖고있다. (상황:차가 고장났다 - 알고리즘(절차):차를 멈추고 살펴본다, 보험사에 연락한다. ...)

* 테트리스
빈 공간을 없애기 위해 블럭을 회전시키자
일상반복적인 일 혹은 문제상황을 효율적으로 개선하려는 것 - 알고리즘의 개선
* 여행가방 싸기
어떤 짐을 어떻게 챙길 것인가?

### 자료구조

데이터를 

* 테트리스
블럭을 공간활용을 잘 할수있게 사각형 모양으로 바꿔서 쌓자

* 여행가방 싸기
어떻게 하면 가방에 공간 효율적으로 짐을 넣을 것인가? 

### 자료구조 + 알고리즘
적절한 모양의 블럭(자료구조) 을 회전시키고 옮겨 (알고리즘) 게임 클리어


## 자료구조
프로세스에서 처리할 데이터가 있을 때 저장장치에서 주기억장치로 불러오게 된다. 주기억장치의 공간은 한정적. 따라서 어떤 형태로 데이터를 불러 올 것인가?
연산의 목적에 따라서도 주기억장치에 배치되는 모양이 달라진다. 
주기억장치로 불러올때 어떻게 효율적으로 배치할지

### 종류
* 원시구조
	* 정수 실수 문자
* 선형구조
	* 배열, 연결 리스트, 스택, 큐, 덱
* 비선형구조
	* 트리, 그래프
### 종류2	
* 물리적구조
	정수 실수 문자
	배열 연결 리스트

* 추상적 구조
	스택 큐 덱 트리 그래프
	
메모리는 1차원 공간이다. 일자로 쭉 연결된 공간이다. (0101010100101) 

#### 배열
같은 형태의 데이터들을 묶어서 관리할 수 있게 한 형태. 
배열은 크기가 정해져있다. 데이터가 하나 더 생겨도 배열 칸을 늘려주지 않는다. 같은 형태의 데이터를 다루기 때문에 데이터 크기가 같아서 배열의 칸의 크기도 전부 같다. (배열도 메모리에 만들어진 가상의 공간임) 

중간에 있는 값을 찾을 때 - 각 칸의 크기가 같기 때문에 배열의 첫머리에서 원하는 칸까지의 위치를 금방 알아서 주소를 알아낼 수 있다. 

단점 - 추가하거나 삭제가 불가능하다. 공간의 크기가 고정적이다. 
장점 - 빠르게 원하는 것을 찾을 수 있다. 


#### 연결 리스트
배열의 단점을 극복. 각 칸을 개별적으로 분리해서 연결해둔다. 마치 기차처럼?
배열과 다르게 연결할 부자재가 더 필요하다. 각 공간의 일정부분은 다음 칸과 연결될 다음칸의 메모리 주소를 저장한다.(논리적인 연결선)
배열에 비해서 공간적으로는 비효율적. 일정부분을 항상 주소를 저장하기 위해 써야하기 때문에. 하지만 삽입과 삭제가 자유.


* 단순 연결 리스트

* 이중 연결 리스트
앞뒤의 위치를 다 알고 있는 경우

* 원형 연결 리스트
머리와 꼬리를 연결

* 이중 원형 연결 리스트


장점 - 삽입과 삭제가 자유롭다.
단점 - 메모리 주소값을 표현하기 위한 공간이 필요해서 공간이 커진다. 중간에 있는 값을 찾을때도 처음부터 주소를 계쏙 추적해서 가야 하기 때문에 비효율적이다. (느리다.) - 속도와 공간 효율을 포기한다...

** 배열은 엄청난 성능(속도)를 원하는 경우 아니면 잘 안쓴다. 현재 컴퓨터의 성능이 좋아져서 리스트의 속도가 느리다는 단점을 극복했기 때문이다.

중간에 데이터 값이 삭제될을 경우 주소값만 넘겨주고 메모리의 칸은  메모리에서 삭제하면 된다.


#### 스택(stack)
나중에 넣은 것을 먼저 빼서 쓰는 방법, 데이터를 차곡차곡 쌓을때(push) 마지막에 넣은 것을 먼저 꺼내 쓰는(pop) 것.

쌓아놓는 느낌,,(스택 오버플로우)

지하철, 뒤로가기버튼, 휴지, 핸드폰 화면이 쌓이는 것(화면순서 스택), 접시쌓기, 총

push-pop

#### 큐(Queue) - 대기열
먼저 넣은(put,인큐) 데이터가 먼저 나간다(get,디큐). 

터널통과, 음식점, 에스컬레이터, 프로세스 큐

#### 덱(Dequeue)
앞뒤에서 넣고 빼고,,, 
스택+큐

#### 트리(tree)
뿌리가 있고 부모와는 일대일 관계, 하위 분류로 나눠갈 수 있다. 탐색에 용이한 형태. 상하관계가 있다. 

root node
branch
node
child node
sibling node

전화번호부, 인구통계, 카테고리 메뉴, 

#### 그래프(graph)
개별 데이터들이 자유롭게 연결되어 있다. 상하관계가 없다. 시작과 끝을 알 수 없다.

네비게이션(최단거리 계산), 페이스북 그래프 (친구 관계) , 상관관계를 통해 소비자 행동 예측

## 알고리즘
일을 처리하는 순서/방법
대표적 알고리즘 - 정렬, 탐색, 재귀 등

시스템 상태, 자료의 분포, 자료의 형태 등에 따라 적합한 알고리즘은 달라진다. 즉 알고리즘에 영향을 미치는 변수는 다양해서 정답인 알고리즘은 없다. 

### 정렬알고리즘
선택정렬
버블정렬
삽입정렬
병합정렬
퀵정렬

#### 선택정렬
전체를 훑어서 최소값을 뽑아내는 것을 반복.

#### 버블정렬 
둘씩 비교해서 큰것을 뒤로 민다. 이게 점점 동시에 일어남.

#### 삽입정렬
들어온 값이 자기보다 큰값은 지나치다 자기보다 작은값을 만나면 사이값인 자리에서 멈춤. 

#### 병합정렬
일정 단위로 비교를 해서 정렬을 하고 그것을 반복하고 서로 합쳐가면서 정렬함. 작은산이 모여서 큰산으로.

#### 퀵정렬 - 어떠한 상황에서도 평균적으로 좋은 성능을 보여서 이름이 퀵
구역을 나눠서 기준을 정하고 앞뒤로 보내면서 정렬을 함. 

#### 정렬된 결과를 역순으로 재정렬할때 성능이 가장 안 좋은 방법은?
데이터 갯수 = n , 걸리는 시간 = k

시간 복잡도

* 선택정렬
k = n+ (n-1) + (n-2) + ....
무한대로 보내면
k = n^2^
O(n^2^) 의 시간복잡도를 갖는다

* 버블정렬
k = (n-1) + (n-2) + ....

O(n^2^) 의 시간복잡도를 갖는다.

* 삽입정렬
O(n^2^) 

* 병합정렬과 퀵정렬은 좀 더 빠르다.
O(nlogn)

### 시간 복잡도
* 알고리즘이 실행되는데 소요되는 시간 분석
* 점근 표기법(대문자 O 표기법)

비고표기법 - 최악의 경우를 가정하고 시간복잡도를 표현 



### 시간복잡도 그래프
O(n) : 리스트와 같은 예. 리스트에서 인덱스로 값 찾기 알고리즘

>코드를 보고 알고리즘의 시간복잡도 계산하라?!
>이중 for문 시간복잡도 = n^2^ (n번돌고 * n번 돌고)

### 탐색 알고리즘의 시간 복잡도
* 선형 탐색 - O(n)
* 이진 탐색 - O(logn)


### 공간 복잡도
최적의 알고리즘은 여건을 고려하여 시간 복잡도와 공간 복잡도 를 감안해야 함. 공간복잡도를 낮추려다 시간 복잡도가 커지기도 하고, 용량과 시간비용등을 고려하여 최적의 알고리즘을 선택해야 한다. 


* 기타
퀵정렬에서도 무조건 평균값을 기준으로 잡는 것도 좋은 방법은 아니다. 한 값이 극단적으로 크다고 할때 평균값을 기준으로 정렬해봤자 효과가 없는 경우...



* 해시테이블
해시 - 유일한 키값에 해당되는 밸류와 쌍으로 이루어진 값
예를들어 우편번호의 경우, 동에 따라서 고유한 밸류값이 있다. (염리동 14515 )
키값은 반드시 유일해야한다!


