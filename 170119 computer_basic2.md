## 운영체제
### 기본
교두보 역할

* 운영체제는 왜 이렇게 다양한가?
사용목적이 달라서?

* 운영체제가 탄생한 이유
초기의 컴퓨터에서는 하드웨어 제어까지(만드는데서 끝까지) 만든사람이 다 제어해줘야했다. 하지만 컴퓨터가 발전해가면서 이것은 비효율적이라 생각. 따라서 하드웨어를 만들고 처음에 최소한 운영되는 정도까지의 시스템 관리나 제어를 할 수 있는 범용적인 소프트웨어를 만들자는 생각에서 출발.

* 운영체제의 종류/계보
운영체제별로 표현하고싶은 바, 원하는 바가 달라서 다양한 종류가 생겨났다.

* UNIX-like OS
유닉스계열 os. 리누스 토발즈가 리눅스 커널을 설계 배포

* 윈도우
범용성에 초점을 두고 설계된 os. 어느하드웨어 환경에서도 쓸 수 있도록. 어디 한군데도 최적화되기 어렵다. 가장 불안정한 운영체제. (유닉스계열에 비해)

* 유닉스
안정성에 초점. 은행전산망등 안전성 담보로 된 시스템에서 많이 사용.


* 최대절전모드
임시파일이 생성되어 메모리의 내용을 그대로 하드에 옮겨놓는다(메모리만큼의 용량을 차지)

* 덤프파일
운영체제의 다잉메세지


### 운영체제 역할

* 시스템 하드웨어 관리
사용자 프로그램의 오류나 잘못된 자원 사용을 감시 
입출력 장치 등의 자원에 대한 연산과 제어를 관리

**응용 소프트웨어가 보내는 메세지 요청 들이 운영체제를 통해서 가도록 설정.(hooking)** 

* (가상)시스템 서비스 제공
사용자에게 컴퓨터의 프로그램을 쉽고 효율적으로 실행할 수 있는 환경 제공
**기본적인 기능들을 운영체제에 구현해놓고 응용프로그램에게 제공, 사용자환경에 맞춘 체계적이고 효율적인 가상세계 제공** 

* **자원관리(핵심기능)**
컴퓨터 시스템 하드웨어 및 소프트웨어 자원을 여러 사용자간에 효율적 할당, 관리, 보호
**자원(메모리, cpu성능, 하드용량 등)은 한정적이기 때문에 아주 중요한 기능이다. 사용범위, 할당량 조절해줌**

### 자원관리
#### 프로세스 관리
* 프로세스란?
메모리에 올려진 상태로 실행되고 있는 프로그램을 말한다. (보조기억장치에 잠들어있는 프로그램 아님) 
1. 프로그램(0과1로 이루어진 일련의 과정) in 보조기억장치
2. 주기억장치로 프로그램을 올린다. 
3. 이 프로그램이 실행된다.

* 로딩중
프로그램을 메모리에 복사중이다.

#### 프로세스 상태
1. 생성 - 프로세스가 생성된다.
2. 준비 - 중앙처리장치에 의해 프로세스가 실행되기를 기다린다.
3. 실행 - 중앙처리장치에 의해 프로세스가 실행된다. (명령어 실행)
4. 대기 - 실행이 끝나면 다음명령 기다림. 
5. 준비 - 

6. 종료 - 프로세스 종료. 

* 준비->실행->준비 상태가 되는 이유?
실행 상태에서 다시 준비상태로 돌아갈 때는 - cpu는 하나인데 처리할 프로세스는 많다. 작업들이 순서를 나눠 처리하고 있다.
1.5GHz cpu일때(Giga:2^30^, 1.5*2^30^*64(bit) = 1초에 처리되는 양)
1920x1080 픽셀 모니터일때 
1920x1080필셀 x 32bit x 60Hz(1초에 화면을 60번 refresh한다) = 1초에 화면을 보여주기위해 처리해야 하는 bit수 
즉, cpu는 어마어마한 작업량을 처리하고 있다. 그래서 여러 프로세스 처리 순서를 정해놓고 조금씩 처리하게 된다. 그래서 준비상태와 실행상태를 번갈아가며 작업을 하게 된다. 

#### 프로세스 스케쥴링
프로세스를 어떻게 cpu에 효율적으로 할당을 해줄것인가
운영체제마다 상이한 스케쥴링 방법을 사용한다. (어차피 알고리즘이 공개되어있지도 않아 확실히 모름)
그래도 멀티큐 방식을 많이 쓰고 있을 것이다.

* FCFS(First-come first-served)
먼저 도착한 명령어 먼저 실행시켜줌.
준비상태 큐에 도착한 순서에 따라 차례로 cpu를 할당
문제점 - 무거운 프로세스가 먼저 도착하면 지연이 생긴다. 

* SJF(shortest Job First)
실행시간이 가장 짧은 프로세스에게 먼저 CPU할당
평균 대기시간이 가장 적은 알고리즘
실행시간이 긴 프로세스에 밀려 무한 연기상태 발생가능 

실행시간이 긴 프로세스는 뒤로 밀려 실행되지 않을 수 있다

* Round Robin Scheduling
시분할 시스템을 위해 고안된 방식
FCFS 기법변형
각 프로세스는 시간 할당량 동안만 실행
완료되지 않으면 다음 프로세스에게CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치
할당된 시간이 클수록 FCFS와 비슷해진다
할당시간이 작을수록 문맥교환(자리를 바꾸는 것-이것도 시간이 걸린다 즉 너무 시간할당량이 작아 자주 바꾸게 되면 작업시간보다 스위칭하는 시간이 더 오래걸릴수도 있다)과 오버헤드가 자주 발생한다
**시간 할당량이 관건이 된다.**

* Priority Based Scheduling
프로세스마다 우선순위 부여
우선순위가 동일한 경우 FCFS기법으로 할당
가장 낮은 순위를 부여받은 프로세스의 무한 연기 발생 가능 

* Multi Queue Scheduling
목적에 따라 우선순위 분류(운영체제가 정해준다)
프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비단계 큐 사용
준비상태 큐 마다 다른 스케쥴링 기법 사용 가능
다른 준비상태 큐로 이동 불가
하위단계 준비 큐에 있는 프로세스를 실행하는 도중이라도 상위 단계 준비상태 큐에 프로세스가 들어오면 상위단계 프로세스에게 CPU할당 
알집 실행시 우선순위 바꾸는 메뉴. 

#### 주기억장치 관리
운영체제가 메모리 공간을 할당해주고 통제,관리한다. 

* 단순관리
	* 메모리안의 공간을 가상으로 나눠서 주소값을 할당하게 된다. 
	* 응용프로그램이 메모리를 많니 쓰면 운영체제가 차지하는 공간을 줄이라고 명령을 함. 그러면 응용프로그램이 필수적이거나 급박한 내용이 아니면 메모리에서 잠시 비워준다. 두세번 했는데 말을 안들으면 운영체제가 강제 종료해서 메모리 공간을 회수한다. 
	* 잘못된 접근 - 할당받지 않은 메모리 공간을 사용하려고 하면 프로세스를 바로 죽여버린다. 블루스크린에 나오는 16진수는 이 메모리 공간에 접근해서 종료시켰다고 알려주는 것. 
* 가상메모리
	* 보조기억장치를 주 기억장치처럼 활용
	* 메모리 공간이 부족하면 보조기억장치 일부를 주기억장치처럼 씀. 하지만 주기억장치보다 읽고쓰는 속도가 느려서 그렇게 좋지 않다. 메모리 용량의 한계때문에 사용하게 되는 것일 뿐이다. 그래서 가상메모리 사용하고 있어도 메모리 공간이 빌때마다 가상메모리에서 끌어와서 채운다.
	
	> 램디스크 - 메모리 용량이 크고 잠시 빠르게 읽고써야 할 파일들이 있을때 메모리 공간에 갖다 두고 쓰는 경우도 있다. 

하드 디스크 - 헤드가 읽는 물리적 속도 한계가 있다. 한번 돌아갈때 한곳만 읽을 수 있다. rpm(1분에 돌아가는 회전수)

 



#### 파일관리
응용프로그램은 파일이 보조기억장치 어디에 있는지 모름 운영체제가 중간에서 가져와준다

응용프로그램 <--파일입출력 요청--> 운영체제 <-- 파일입출력처리--> 보조기억장치

운영체제가 보조기억장치에 파일을 0101001로 변환시켜 저장한다. 

* 저장할때,
운영체제가 하드디스크에 인덱스를 만들어 저장한다. 하드디스크 섹터의 어디서부터 어디까지는 어떤 파일이다는 것을 기억해둔다. 파일시스템 경로는 가상의 공간,가상의 경로일 뿐이다. 드라이브 파티션을 나눌때는 논리적으로 실제 공간(섹터)를 나눠놓는다. (논리파티션)

* 포맷할때
파일이 어디 저장되어있는지 알고있는 인덱스, 파일테이블,(로그?) 만 지운다. 물리적으로 파손되지 않는 이상 모두 복구가 가능하다. 
파일 테이블을 없애버리면, 테이블에 써져있지 않은 공간은 빈공간으로 인식하고 새로 파일을 작성할때 덮어 쓰게 된다. - 복원이 힘들어짐. 

* 파일
파일을 쓸 때 0과1로 되어있어도 일정한 규칙이 있다. (파일명, 작성자 등을 기록하는 자리 등) 

#### 파일 시스템
운영체제마다 파일을 관리하는 방법이 다르다. 읽고 쓰는 방법, 테이블 만드는 방법이 다르다. 맥에서 썼던 usb 윈도우에 꽃으면 안되는 경우. 인덱스파일

확장자를 바꾸면(txt 를 exe로 바꾸면) 읽지 못할까? - 그래도 메모장에서 텍스트형식으로 읽을 수 있다. 확장자는 파일명의 한 부분이라 힌트를 주는 보조수단이지 파일의 고유한 내용이 변하는 것은 아니다. 

* Unix - unix file system

* linu - 확장파일 시스템,zfs,xfs...

* mac os - hfs, hfs+...

* windows - fat, ntfs


* a드라이브 : 5.25인치 / b: 3.5 / c: hdd /  d : odd (드라이브명은 전통적인 것..?)

* 조각모음
맥에는 조각모음이 없는 이유? - 파일시스템의 차이때문. 윈도우는 파일을 분산시켜서 쓰고 뒷부분에 다음파일의 위치를 써준다. 그래서 속도 저하를 막기위해 조각모음을 해서 파일을 하나로 합쳐준다.ssd는 읽고 쓰는 수명이 잇음. 조각모음 하지 않는게 더 수명에 좋다. ssd를 가상메모리로 쓰는 것도 마찬가지로 안좋다. 셀의 수명이 금방 다하게 된다. 그치만 사실은 실제로 그렇게 신경써야 할 정도로 수명이 다하는 것은 아니다.


### 커널
애플리케이션과 커널만으로도 동작은 가능하다 .

운영체제의 핵심이자 정체성. 보안, 자원관리, 추상화 - 하드웨어를 일정한 구조로 나타내서 관리할 수 있도록 추상화

* 커널
운영체제안에 커널이 존재. 하드웨어를 제어하고 통제하고 운영하는 총체적인 역할. 운영체제의 핵심기능은 모두 커널에 들어있다고 보면 된다. 운영체제의 중추. 
커널을 제외한 운영체제의 기능들 - 유저인터페이스, 가상메모리 제공, 유틸리티 제공 등

* 드라이버
마우스, 키보드 등은 표준을 따르고 있고 단순해서 운영체제가 관리하기 쉬운 하드웨어. 하지만 다른 장치들의 경우 장치가 보내는 고유한 신호를 운영체제가 해석하기 어려울 수 있어서 만들어둔 소프트웨어. (운영체제에게 이런식으로 신호를 받으면 된다, 해석하면 된다 이런것들을 알려줌)

* 펌웨어
칩셋에 박혀있는 하드웨어 소프트웨어. 요즘에는 소프트웨어적으로 교체가 가능하다.

#### 프로그램 설치
설치파일 - 압축되어있는 실행파일
윈도우 레지스트리에 경로를 등록해주는것이 필요. 



## 동작순서-흐름
 사용자 입력 - os가 신호를 인식
 어플리케이션을 메모리에 복사하고 프로세스 실행
 재생할 음악 선택해서 클릭 (입력)
 os에서 신호를 어플리케이션에 전달 
 어플리케이션이 파일 전달 요청 (os에게)


1. 마우스 클릭 - 신호가 마우스 드라이버 통해 커널이 해석하고 운영체제가 수신 
2. 운영체제가 어느 app이 수신해야하는지 파악하고 어플에게 알려준다
3. 어플이 운영체제에게 음악파일 불러달라고 부탁
4. 운영체제는 인덱스로 파일을 찾아서 메모리에 복사해둠
5. 운영체제가 어플에게 메모리에 복사해놧다고 알려줌
6. 메모리가 cpu로 명렁어를 보냄 
7. 연산과 수행, 메모리에 저장
8. 어플이 운영체제에게 메모리에 저장된 결과를 스피커로 보내달라고함
9. 운영체제가 커널을 통해 스피커로 보내줌 -> 출력


음악파일을 디코딩 하는 것도 어플리케이션이방법을 알고 있고, 그것을 cpu에게 알려주면 cpu가 연산함. 


사용자 : 연산명령을 입력장치를 통해 전달
입력장치 : 응용프로그램에게 사용자입력 전달 @
응용 프로그램  주기억장치로 명령 복사 @
주기억장치: cpu로 명령 복사
cpu:명령 수행 후 주기억장치로 결과 복사
응용 프로그램 : 결과값을 보조기억장치에 저장 @ 
응용프로그램 : 결과값을 출력장치로 전달 @
출력장치 : 사용자에게 전달


### 멀티태스킹
싱글코어
멀티코어


## 데이터베이스
### 데이터베이스
db
여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합
통합된 정보들을 저장하여 운영할수 있는 공용 데이터들의 묶음


### 자료구조 vs 데이터베이스
* 자료구조 : 대부분 주기억장치에서 이루어질 내용
* 데이터베이스 : 대부분 보조기억장치에서 이루어질 내용

### 데이터베이스 종류
* 관계형 - 대규모 시스템에서 많이 쓴다. 속도가 빠르기 때문. 설계 확장 수정이 까다롭고 어렵다. 
* 키-값형
* 객체형
* 문서형
* 컬럼형

* Django 는 관계형 모델을 쓰지 않고 추상화 시켜줌. 
* noSQL - 관계형이 아닌 db들을 통칭

### 정규화
데이터 베이스 모델을 효율적으로 운용할 수 있는 설계 방법

### DBMS
* dataBase Management system
* DB에 접근할 수 있는 기능을 제공하는 소프트웨어 즉, 데이터베이스계의 운영체제
* MySQL, PostgreSQL, SQLite, MariaDB,... (!= DB, 즉 데이터베이스는 관계형이면서 DBMS로 MySQL을 사용한다고 해야 한다. 명확한 표현에 주의!! 우리 db mySQL써는 틀린 표현) 

### SQL
* structured Query Language(구조화된 질의문-DBMS에게 요청하는 문법)
* DBMS를 통해 데이터를 관리하기 위한 구조화된 질의문을 작성하기 위한 언어
* 관계형 데이터베이스 관리 시스템에서 사용



